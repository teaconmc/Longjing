import org.gradle.api.Project
import org.gradle.api.tasks.bundling.AbstractArchiveTask

afterProject { project ->
    // Only do this on root project for now. 
    // We are not sure about multi-project builds - we will come back later.
    if (project != rootProject) {
        return
    }

    // Try locating the task that produces production-ready artifact.
    // The precedence, from high to low, is as following:
    //   1. If environmental variable TEACON_ARTIFACT_TASK is defined, then we will use the value of that 
    //      environmental variable as the name of the task to use.
    //      Example: if we specify TEACON_ARTIFACT_TASK=my_task, then we will find task with name of `my_task'.
    //      Specifying a task within sub-project is possible: if we specify TEACON_ARTIFACT_TASK=:fabric:my_task, 
    //      then we will find task with name of `my_task' under sub-project named `fabric'.
    //   2. If plugin `com.github.johnrengelman.shadow` is present, use `shadowJar` from that plugin.
    //   3. If `remapJar` exists, use that task
    //   4. Use `jar`, failing if not found.
    // The task is expected to have type of org.gradle.api.tasks.bundling.AbstractArchiveTask.
    def targetTask = null
    if (System.env.TEACON_ARTIFACT_TASK) {
        // If env var TEACON_ARTIFACT_TASK is present, use this over everything else.
        // Longjing is responsible for reading the correct value from Biluochun and set it up before 
        // starting up a Gradle build.
        def targetTaskName = System.env.TEACON_ARTIFACT_TASK
        // There is TaskContainer.findByPath, however using that will have side effect (i.e. pre-loading 
        // the task), thus its usage is avoided. 
        // To properly support task within a sub-project, we have to replicate its logic of locating 
        // subproject, hence the string splitting.
        def targetProject = project
        def splitPoint = targetTaskName.lastIndexOf(Project.PATH_SEPARATOR)
        if (splitPoint > 0) {
            def targetProjectPath = targetTaskName.substring(0, splitPoint)
            targetProject = project.findProject(targetProjectPath)
            targetTaskName = targetTaskName.substring(splitPoint + 1)
            if (targetProject == null) {
                println "::error title=Invalid TEACON_ARTIFACT_TASK Detected!::你所指定的输出任务中包含有 Gradle 子项目名 $targetProjectPath，但该子项目实际并不存在！"
            }
        }
        targetTask = targetProject.tasks.named(targetTaskName)
    } else if (project.pluginManager.hasPlugin("com.github.johnrengelman.shadow")) {
        // If shadow plugin is present, prioritize the shadowJar task
        targetTask = project.tasks.named('shadowJar')
    } else {
        try {
            // If remapJar task is present, assuming that Fabric Loom or Architectury Loom is present, 
            // and prioritize the remapJar task.
            targetTask = project.tasks.named('remapJar')
        } catch (UnknownTaskException e) {
            // This is the conventional task to produce the jar. ForgeGradle uses it.
            // This should not fail. If it fails, either we need to add more special case, or 
            // the project setup has more serious problem.
            targetTask = project.tasks.named('jar')
        } 
    }

    project.tasks.register('teaconLongjingProcessing') {
        doLast {
            def fileSizeLimit = 10 * 1024 * 1024 // 10485760 bytes, aka 10MiB
            if (System.env.GITHUB_ACTIONS) {
                // We assume that the task is of type AbstractArchiveTask.
                assert targetTask.get() instanceof AbstractArchiveTask
                def theFile = targetTask.get().archiveFile.get().getAsFile()
                // Open the env file provided by GitHub Action
                // Ref: https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#environment-files
                def envFile = new File(System.env.GITHUB_ENV)
                // Use the env-specific line separator for maximally possible compatibility
                def newLine = System.getProperty('line.separator')
                // Write out new env variable for later usage
                envFile << newLine << "ARTIFACT_NAME=${targetTask.get().archiveFileName.get()}"
                envFile << newLine << "ARTIFACT_LOCAL_PATH=${theFile.absolutePath}"
                // Similarly, we write artifact path to action output
                def actionOutputFile = new File(System.env.GITHUB_OUTPUT)
                actionOutputFile << newLine << "artifact=${theFile.absolutePath}"
            }
        }
    }
}
